from aiohttp import web
import os
import asyncio
import subprocess
import zipfile



# Allowed image extensions
ALLOWED_EXTENSIONS = {
    '.jpg',
    '.jpeg',
    '.png',
    '.gif',
}

STATIC_DIR = "static"

def allowed_file(filename: str) -> bool:
    """ Check if the file has an allowed extension. """
    return filename.endswith(tuple(ALLOWED_EXTENSIONS))

async def save_uploaded_file(file, filename) -> str:
    """ Save the uploaded file to disk. """
    file_path = os.path.join(STATIC_DIR, filename)
    with open(file_path, 'wb') as f:
        while True:
            chunk = await file.read_chunk()  # 8192 bytes by default.
            if not chunk:
                break
            f.write(chunk)
    return file_path

def unzip_file(zip_path, extract_to) -> str:
    """Extracts a ZIP file to a specified directory without overwriting existing files, returning the operation's status as a string."""
    try:
        # Ensure the paths are correctly sanitized and absolute
        subprocess.run(['unzip', '-n', zip_path, '-d', extract_to], check=True)
        return "Unzip successful."
    except subprocess.CalledProcessError as e:
        return f"Failed to unzip file: {str(e)}"

async def handle_zip_file(file, filename) -> str:
    """ Handle the uploading and processing of a ZIP file using external unzip command. """
    file_path = await save_uploaded_file(file, filename)

    # Explicitly flush and sync file changes to disk (if needed)
    os.sync()

    # Verify the zip file's contents before extraction
    if not filename.lower().endswith('.zip'):
        return "File is not a zip archive."

    try:
        with zipfile.ZipFile(file_path, 'r') as zip_ref:
            for contained_file in zip_ref.namelist():
                # Check each file in the ZIP to ensure it has an allowed extension
                if not os.path.basename(contained_file).lower().endswith(tuple(ALLOWED_EXTENSIONS)):
                    return f"Zip file contains unsupported file types or directories: {contained_file}"

        # Perform the extraction using the unzip_file function
        unzip_status = await asyncio.get_event_loop().run_in_executor(None, unzip_file, file_path, STATIC_DIR)
        if not unzip_status.startswith("Unzip successful"):
            return unzip_status

        # Ensure the command has fully completed before moving on
        await asyncio.sleep(1)  # Small delay to ensure file system catches up, adjust as necessary

        # Remove the original ZIP file after extraction
        os.remove(file_path)

    except zipfile.BadZipFile:
        return "Invalid ZIP file."

    except FileNotFoundError as e:
        return f"File not found. Message: {str(e)}"

    return "ZIP file has been uploaded and extracted successfully."

async def handle_regular_file(file, filename) -> str:
    """ Handle the uploading of a regular image file. """
    await save_uploaded_file(file, filename)
    return f"File {filename} has been uploaded successfully."

async def upload_file(request) -> web.Response:
    reader = await request.multipart()
    file = await reader.next()
    if file is None:
        return web.Response(status=400, text="No file provided")

    filename = file.filename
    if not filename:
        return web.Response(status=400, text="Filename is missing")

    if filename.endswith('.zip'):
        result = await handle_zip_file(file, filename)
    else:
        if not allowed_file(filename):
            return web.Response(status=400, text="File type not allowed.")
        result = await handle_regular_file(file, filename)

    return web.Response(text=result)